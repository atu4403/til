# Conventional CommitsとSemantic VersioningとCHANGELOG

[Conventional Commits](https://www.conventionalcommits.org/en/v1.0.0/)

Conventional Commitsはコミットメッセージのルールです。このルールに従うことで以下のメリットがあります。

- CHANGELOG.md等の作成を自動化できる
- コミットの内容が明確になる
- Semantic Versioningの運用が容易になる

## コミットメッセージの書き方概要

- 新機能追加は`feat:`から始める(minor)
- バグの修正は`fix:`から始める(patch)
- 破壊的変更は`feat!:`から始める(major)

この`feat:`や`fix:`はタグといいます。それ以外のタグは自由に設定できますが、一般的なのは以下の通りです。

```text
✨ feat: 新しい機能
👻 fix: バグ修正
📖 docs: ドキュメントの変更のみ
📐 style: コードの意味に影響しない変更 (空白、書式、セミコロンの欠落など)
🧹 refactor: バグを修正したり、機能を追加したりしないコード変更
🏃 perf: パフォーマンスを向上させるコード変更
〽 test: 不足しているテストを追加するか、既存のテストを修正する
📥 chore: ビルドプロセスや補助ツールやライブラリ (ドキュメント生成など) の変更
```

## Semantic Versioningとの関係

[セマンティック バージョニング 2.0.0 | Semantic Versioning](https://semver.org/lang/ja/)

Semantic Versioning、`major.minor.patch`(または`x.y.z`)のバージョンナンバーについて、`feat!:`はメジャーアップデート、`feat:`はマイナーアップデート、その他はパッチアップデートになります。

プロジェクトの目指すものは様々なので一概には言えませんが、`git`のようなコマンドラインアプリケーションを例に考えます。

`git switch`という新しい機能を追加したら`feat:`タグを付けるマイナーアップデートです。`x.Y.z`の`Y`の数字が上がります。

ここでわかりにくいのは、機能を削除した場合です。

`git checkout`という機能を削除したら`feat!:`タグを付けるメジャーアップデートです。`X.y.z`の`X`の数字が上がります。
削除なのに新機能とは違和感がありますが、破壊的変更を伴うのはユーザーにとって新機能です。

しかし`git checkout`を削除せず、内部で使われている関数を廃止して別の関数に書き換えるのなら`refactor:`タグを付けるパッチアップデートです。

コミットメッセージがそのままCHANGELOGになると思えば想像しやすいかと思います。

## v0の意味

メジャーバージョン`0`は開発版を意味します。開発中は仕様が固まっておらず、機能の追加や廃止（破壊的変更）が頻発するものと捉えられます。
ユーザーは、バージョン0のものは「昨日使えてた機能が使えなくなる」と解釈するので、仕様が固まったらメジャーバージョンを1にしてreleaseすべきです。

## コミットの粒度

コミットメッセージに合わせたコミットを行います。

例えば新機能追加のコーディングをしている時にバグが見つかった。バグを修正して新機能も完成した。

```diff
def aaa():
-   return 1
+   return 0

+ def bbb()
+     return aaa() + 1
```

これを１度にコミットしてしまうとConventional Commitsの`feat`と`fix`が混在してしまうので以下のように2つのコミットに分けます。

- fix: aaaを修正
- feat: bbbを追加

同じファイルのコミットを行ごとで分けるには`git add --interactive`や`git add --patch`で行うことができます。

[Git - 対話的なステージング](https://git-scm.com/book/ja/v2/Git-%E3%81%AE%E3%81%95%E3%81%BE%E3%81%96%E3%81%BE%E3%81%AA%E3%83%84%E3%83%BC%E3%83%AB-%E5%AF%BE%E8%A9%B1%E7%9A%84%E3%81%AA%E3%82%B9%E3%83%86%E3%83%BC%E3%82%B8%E3%83%B3%E3%82%B0)

しかし直感的にわかりにくいので`gitup`を使う方法がオススメです。

[GitUp](https://gitup.co/)

![gitup](/images/howto_conventional-commits/2021-12-23-17-25-15.png)

行をクリックして選択し、`Stage Lines`をクリックすると選択した行だけステージングできます。

ちなみにvscodeはソース管理ウインドウからファイルを選択→該当箇所を選択して右クリック→選択した範囲をステージング、で行ごとのステージングが可能。

## .gitmessage

テンプレートを作っておけば`git commit`とmオプションなしで実行した時にエディタが開き、テンプレートがある状態からコミットメッセージを書くことができます。

テンプレートファイルの場所はどこでもいいです。

```text
# ✨ feat: 新しい機能
# 👻 fix: バグ修正
# 📖 docs: ドキュメントの変更のみ
# 📐 style: コードの意味に影響しない変更 (空白、書式、セミコロンの欠落など)
# 🧹 refactor: バグを修正したり、機能を追加したりしないコード変更
# 🏃 perf: パフォーマンスを向上させるコード変更
# 〽 test: 不足しているテストを追加するか、既存のテストを修正する
# 📥 chore: ビルドプロセスや補助ツールやライブラリ (ドキュメント生成など) の変更
# <BLANK LINE>
# <body>
# <BLANK LINE>
# <footer>
```

このようなテンプレートを作ると、コミットメッセージを書く時に必要な行のコメントを外すだけで書けます。(#から始まるコメント行は残しておいてもコミットメッセージに含まれません)

作成したら`~/.gitconfig`にテンプレートのパスを書いておきます。これでコミット時に自動で反映されます。

```bash
[commit]
    template = /Users/atu/.config/.gitmessage.txt
```

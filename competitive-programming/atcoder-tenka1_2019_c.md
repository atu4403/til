# AtCoder: C - Stones

[C - Stones](https://atcoder.jp/contests/tenka1-2019-beginner/tasks/tenka1_2019_c)

## 問題概要

`#`と`.`からなるN文字の文字列がある。0文字以上修正して`#.`という部分をなくしたい。最低何文字修正したら良いか。

## 制約

1 ≦ N ≦ 200000

## 考えたこと

左から連続する`.`と右から連続する`#`は除外して、残りを全て`.`もしくは`#`に変換すればOK、と考えてWA。(例えば`#...##.#.#`は3が正解)

3文字の条件を満たすのは`###`や`...`の他にも`.##`や`..#`もある。このいずれかの形になればOKなので以下のようにシミュレートしていく。

1. `###`に修正する為に必要な回数
1. `.##`に修正する為に必要な回数
1. `..#`に修正する為に必要な回数
1. `...`に修正する為に必要な回数

例えば`.##`に修正する為に必要な回数を求めるには2文字目未満の`#`の個数と、2文字目以降の`.`の個数を足せば良い。

具体的には0始まりの累積和を作り、1からNまでの`i`について左の`#`と右の`.`を数える。

問題が`#.#`の場合、累積和は`[0, 1, 1, 2]`となる。最初の`0`は累積和のために追加した要素なので、探索するには`1`から`N`まで(`N-1`ではない)を確認すれば良い。

- `i`未満の`#`の数: `累積和[i-1]`
- `i`以上の`#`の数: 総和(累積和の最後の値) - `累積和[i]`
- `i`以上の`.`の数: `i`以上の要素数 - `i`以上の`#`の数

```python
from itertools import accumulate

N = int(input())
S = input()
a = list(accumulate([1 if s == "#" else 0 for s in S], initial=0))
ans = 10 ** 10
for i in range(1, N + 1):
    w = a[i - 1]
    b = (N - i) - (a[-1] - a[i])
    ans = min(ans, w + b)
print(ans)
```

pythonの`itertools.accumulate`で累積和が作れるが、`[1, 2, 3]`の累積和は`[1, 3, 6]`となる。`[0, 1, 3, 6]`という形にしたいなら引数に`initial=0`と加えることで可能。
